-- ./mad ex-fodo.mad

!-- user settings
local deltap = 1e-3  -- to play with deltap
local charge = 1     -- to play with particle charge 1 or -1.
local ncell  = 10    -- number of fodo cells
local lcell  = 10    -- single cell length

!-------------------------------------------------------------------------------

local refdir = \s -> 'ex_ref/'..(s or '')
local rundir = \s -> 'ex_run/'..(s or '')
MAD.filesys.mkdir(rundir())
MAD.option.numfmt = "% -.16e"

-- locals
local beam, beta0, sequence, survey, track, cofind, twiss, match, option in MAD
local sbend, quadrupole, sextupole in MAD.element
local printf in MAD.utility
local lbool in MAD.gfunc
local dp2pt in MAD.gphys
local pi in math

!---------------------------------------
!-- make sequence and beam
!---------------------------------------

local function mk_seq ()
  -- classes
  local mb = sbend      { l=2 }
  local mq = quadrupole { l=1 }
  local ms = sextupole  { l=0.5 }

  -- prepare beam depending on the user's charge sign...
  local sb = beam { particle = charge<0 and 'electron' or nil, energy=2 }

  printf("particle: '%s', charge = %d, energy = %g, mass = %.8e\n",
             sb.particle,   sb.charge,   sb.energy,     sb.mass)

  -- parametric fodo cell (for fun, could use deferred expressions)
  local cell = \ang, chg -> sequence 'cell' {
      l=10, refer='entry',
      mq 'qf' { at=0, k1=chg*0.3 },
      ms 'sf' {       k2=0       },
      mb 'b1' { at=2, k0=chg*ang/mb.l, angle=ang },

      mq 'qd' { at=5, k1=chg*-0.3 },
      ms 'sd' {       k2=0        },
      mb 'b2' { at=7, k0=chg*ang/mb.l, angle=ang },
    }

  -- build full ring, attach beam     -- 2 mb per fodo cell
  return sequence 'seq' { beam=sb, ncell*cell(pi/ncell, sb.charge) }
end

!---------------------------------------
!-- match tunes and chromaticities
!---------------------------------------

local function match_tunes_and_chroma (seq, X0)
--[[   io.write("-------------------------------\n")
  io.write("  MATCHING TUNES : 2.34, 2.29  \n")
  io.write("  MATCHING CHROMA: 5.00, 5.00  \n")
  io.write("-------------------------------\n") ]]

  return match {
    command := twiss { sequence=seq, method=4, observe=1,
                       X0=X0, deltap=deltap, chrom=true },
    variables = { rtol=1e-6,    -- 1 ppm, Power Converter usual resolution...
      { var = 'seq.qf[1].k1' }, -- elements are shared by all cells,
      { var = 'seq.qd[1].k1' }, -- varying one cell varies them all
      { var = 'seq.sf[1].k2' },
      { var = 'seq.sd[1].k2' },
    },
    equalities = {
      { expr = \t -> t.q1-2.34, name='q1' , tol=1e-8 },
      { expr = \t -> t.q2-2.29, name='q2' , tol=1e-8 },
      { expr = \t -> t.dq1-5.0, name='dq1', tol=1e-4 },
      { expr = \t -> t.dq2-5.0, name='dq2', tol=1e-4 },
    },
    maxcall=100, !info=2, debug=2
  }
end

!---------------------------------------
!-- study starts here
!---------------------------------------

!-- use sequence
local seq = mk_seq()

!-- initial conditions
local X0 = {-1e-3,1e-4, -1e-4,1e-3, 0,0}

!-- columns selection
local tk_col = {'name', 's', 'x', 'px', 'y', 'py', 't', 'pt' }
local tw_col = {'name', 's', 'x', 'px', 'y', 'py', 't', 'pt',
                'beta11', 'beta22', 'mu1', 'mu2', 'alfa11', 'alfa22',
                'dx', 'dpx', 'dy', 'dpy'}

!-- sanity check
-- printf("deltap to pt= %.16g\n", dp2pt(deltap, seq.beam.beta))

-- check geometry
-- print("survey...")
local srv = survey { sequence=seq } :write(rundir('survey_n'))

-- track (no closed orbit)
-- print("track...")
b0 = beta0({table.unpack(X0)})
b0.beta11 = b0.beta11 / (1 + deltap) --Adjustment for MAD-X
b0.beta22 = b0.beta22 / (1 + deltap) --Adjustment for MAD-X
b0.beta33 = b0.beta33 / (1 + deltap) --Adjustment for MAD-X

local trk, mfl = track { sequence=seq,
  X0=X0, deltap=deltap, method=4, observe=0, info=2, !debug=7
}
trk:write(rundir('track_n'), tk_col)

-- cofind --------------
-- print("cofind...")
local trk, mfl = cofind { sequence=seq,
  X0=X0, deltap=deltap, method=4, observe=0, save=true, info=2, !debug=7
}
trk:write(rundir('cofind_n'), tk_col)

-- twiss (no closed orbit)
print("twiss-noco...")
tws, mfl = twiss { sequence=seq,
  X0=b0, deltap=deltap, method=4, info=2, !debug=7
}
tws:write(rundir('twiss0_n'), tw_col)

-- twiss (with closed orbit)
print("twiss-co...")
tws, mfl = twiss { sequence=seq,
  X0=X0, deltap=deltap, method=4, mapdef=5, info=2, chrom=true, implicit=true, !debug=7,
}
tws:write(rundir('twiss1_n'), tw_col)

do return end

-- match ---------------
X0[5], X0[6] = 0, 0 -- reset t,pt because we use deltap!
match_tunes_and_chroma (seq, X0)

-- twiss ---------------
local tws, mfl = twiss { sequence=seq,
  X0=X0, deltap=deltap, chrom=true, method=4,
}
tws:write(rundir('twiss_match_n'))

-- backtracking --------

-- survey --------------
local rsrv = survey { sequence=seq, dir=-1 } :write(rundir('survey_rev_n'))

-- twiss ---------------
local rtws, rmfl = twiss { sequence=seq, dir=-1,
  X0=X0, deltap=deltap, chrom=true, method=4,
}
rtws:write(rundir('twiss_match_rev_n'))

-- knobs --------

local damap in MAD
local X0 = damap {nv=8, mo=2, nk=2, ko=1,
                  vn={'x','px','y','py','t','pt','k1f','k1d'}}

-- tpsa           scalar       tpsa
seq.qf[1].k1 = seq.qf[1].k1 + X0.k1f
seq.qd[1].k1 = seq.qd[1].k1 + X0.k1d

local trk, mflw = track { sequence=seq, X0=X0, method=4 }
trk:write(rundir('track_knobs_n'))


--------------------------------------------------------------------------------