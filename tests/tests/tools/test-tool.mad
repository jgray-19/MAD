local is_vector      in MAD.typeid
local fnil           in MAD.gfunc
local atexit, tblcpy in MAD.utility

local help_usage = [[Usage: ../mad <your_test_suite.mad> [options] [testname1 [testname2] ... ]
Options:
  -h, --help:             Print this help
  -v, --verbose:          Print during and after the test.
  -d, --debug:            Stop on first failure and run dbgmap on PTC and MAD output (saved in output/)
  -s, --save:             Save the config and results to a file
  -n, --norun:            Do not run tests, just read cfg and res files and continue with other options
  -f, --figure:           Generate a figure for each test in output/plots
  -g, --gutest:           Generate unit tests for the current configuration
  -c, --cmap:             Use the C++ maps instead of the Lua maps for the test
  -t, --test:             Do not run unittests, instead run as a test where PTC is 
                          run for every configuration.
  -p, --pattern PATTERN:  Execute all test names matching the Lua PATTERN
                          May be repeated to include several patterns
                          Make sure you escape magic chars like +? with %
  -x, --exclude PATTERN:  Exclude all test names matching the Lua PATTERN
                          May be repeated to exclude several patterns
                          Make sure you escape magic chars like +? with %
  testname1, testname2, ... : tests to run in the form of TestClass or TestClass.testMethod
]]

local unittest_help = [[

Additional/Augmented options for unit tests, provided for tests against PTC:
  -v, --verbose:          Augmented to also print during the test.
  -d, --debug:            Run dbgmap on PTC and MAD output (saved in output/) before assertion failure
  -g, --gutest:           Generate as the unit tests is ran
  -s, --save:             Save the config and results to a file
  -c, --cmap:             Use the C++ maps instead of the Lua maps for the utest
  -t, --test:             Do not run unittests, instead run as a test where PTC is 
                          run for every configuration.
Note: Plots are automatically generated for all utests in output/plots
]]


local args_dict = { -- Do opposite to default
  ["--save"   ] = "dosave"   ,
  ["-s"       ] = "dosave"   ,

  ["--verbose"] = "doprnt"   ,
  ["-v"       ] = "doprnt"   ,

  ["--debug"  ] = "dodbg"    ,
  ["-d"       ] = "dodbg"    ,

  ["--figure" ] = "doplot"   ,
  ["-f"       ] = "doplot"   ,

  ["--norun"  ] = "dorun"    ,
  ["-n"       ] = "dorun"    ,

  ["-gutest"  ] = "gen_utest",
  ["-g"       ] = "gen_utest",

  ["--cmap"   ] = "cmap"     ,
  ["-c"       ] = "cmap"     ,

  ["-h"       ] = "help"     ,
  ["--help"   ] = "help"     ,

  ["-p"       ] = "pattern"  ,
  ["--pattern"] = "pattern"  ,

  ["-x"       ] = "exclude"  ,
  ["--exclude"] = "exclude"  ,

  ["-t"       ] = "test"     ,
  ["--test"   ] = "test"     ,
}

-- Some test specific tables
local patterns, excludes, tests_to_run = {}, {}, {}

local global_cfg   = {dorun = true}
local mad_args     = tblcpy(MAD.env.arg) -- Copy the arg list for manipulation

local args_to_cfg = \cfg => for k, v in pairs(global_cfg) do cfg[k] = v end end

local function run_help (is_unittest) 
  if is_unittest then atexit(\->print(unittest_help)) 
  else                print(help_usage) ; os.exit(0) 
  end
end

-- A function to get the pattern or exclude from the arg list
local function get_pttrn_or_excl (i, is_unittest, tbl)
  if is_unittest then return end
  local pttrn = mad_args[i + 1]
  if not pttrn or pttrn:sub(1,1)=="-" then -- Check if the next arg is a pattern
    error("Missing argument for option: "..mad_args[i]) 
  end
  -- Add pattern to corresponding table and remove the pattern from the arg list
  tbl[#tbl+1], mad_args[i+1] = pttrn, ""
end
 
local arg_fun = {
  pattern = \i, iut-> get_pttrn_or_excl(i, iut, patterns),
  exclude = \i, iut-> get_pttrn_or_excl(i, iut, excludes),
  help    = \_, iut-> run_help(iut),
  test    = fnil,
}

local args_in_utest = {
  doprnt   = true,
  doplot   = true,
  pattern  = true,
  exclude  = true,
  help     = true,
}

local function remove_arg (is_unittest, i, arg)
  if is_unittest and not args_in_utest[arg] then
    table.remove(MAD.env.arg, i + (#MAD.env.arg - #mad_args))  -- Remove the arg from the arg list
  end
end

local function parse_cmd_args() -- Parse the command line arguments
  -- First check if this is a unittest
  local is_unittest = true
  for _, v in ipairs(mad_args) do 
    if args_dict[v] == "test" then is_unittest = false end
  end

  -- Now parse other arguments
  for i, v in ipairs(mad_args) do

    --Check if the argument is an option
    if v:sub(1,1) == "-" then
      local arg = args_dict[v] -- Get the argument name

      if arg_fun[arg] then
        -- If the argument has a function, run it
        arg_fun[arg](i) 
        remove_arg(is_unittest, i, arg)
      elseif arg then
        -- If the argument is a known cfg boolean, set it (True for all but norun (sets dorun to false))
        global_cfg[arg] = not global_cfg[arg]

        -- For compatibility with unittests, remove the arg from the arg list, except for verbose option
        remove_arg(is_unittest, i, arg)
      else
        error("Unknown option: "..v)
      end

    -- Check if the argument is a test name 
    -- "" is a special case that can only occur due to get_pttrn_or_excl
    elseif v ~= "" then 
      tests_to_run.__RUN_ALL__ = false -- Set to false if a test name is given
      -- Find the position of the dot (if any)
      local dot_pos = string.find(v, "%.") or 0
      if dot_pos == 0 then 
        tests_to_run[v] = true 
      else
        -- Get the module and test name, using the dot position, then
        -- add the test to the list of tests to run
        local mod, test = v:sub(1, dot_pos-1), v:sub(dot_pos+1)
        if tests_to_run[mod] then tests_to_run[mod][test] = true
        else                      tests_to_run[mod] = {[test] = true} 
        end
      end
    end
  end
  return not is_unittest -- Return true if this is not a unittest
end

local function chk_test(mod_name, test_name) -- Check if the test should be run
  if #patterns == 0 and #excludes == 0 and tests_to_run.__RUN_ALL__ then 
    return true -- No patterns, excludes or selected tests to run, so run all tests
  end
  if tests_to_run[mod_name] then -- Module is in the list
    if     tests_to_run[mod_name] == true    then return true
    elseif tests_to_run[mod_name][test_name] then return true 
    end
  end

  local chk = false
  -- Check if the test name matches any of the patterns
  for _, p in ipairs(patterns) do 
    if string.find(test_name, p) then chk = true end
  end

  -- Now check if the test name matches any of the excludes
  for _, x in ipairs(excludes) do -- Exclude has priority
    if string.find(test_name, x) then chk = false end
  end
  return chk
end

local function chk_unknown_tests (ran_tests)
  for t, _ in pairs(tests_to_run) do
    if t ~= "__RUN_ALL__" and (not _G[t] or ran_tests[t]) then -- t can be a module or a test
      print("Could not find and run the following test:  ".. t)
    end
  end
end

local is_test_name = \s -> type(s) == "string" and string.sub(s, 1, 4):lower() == 'test'
local function run_tests ()
  local test_names = {}
  for k, v in pairs(_G) do
    if is_test_name(k) then
      assert(type(v) == "table", "All tests must be placed in a module")      -- Possibly limiting?
      for t, f in pairs(v) do
        if is_test_name(t) and chk_test(k, t) then test_names[t] = f end
      end
    end
  end
  chk_unknown_tests(test_names)
  for t, f in pairs(test_names) do f() end
end

return {
  parse_cmd_args = parse_cmd_args,
  args_to_cfg    = args_to_cfg   ,
  run_tests      = run_tests     ,

  -- For adapting the unittests
  args_dict      = args_dict     ,
  arg_fun        = arg_fun       ,
  global_cfg     = global_cfg    ,
}